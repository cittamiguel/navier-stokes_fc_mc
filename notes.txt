To fit data arrays in atom's memory system hierarchies use the following ecuation

N<sqrt( memSize / (2**5)*6)   ~aproximation

6 bc there are 6 arrays intizialized, 2**5 bc sizeof(float)


memory footprint of data estimated to be ~ N**2 * 2**5 * 6


---> to fit in L1d => N < 256, 
               L2 => 256 < N < 1024,
               L3 => 1024 < N < 3344

when using /usr/bin/time we get a max resident memory footprint > L1 size even using N's as low as 8, but this is also accounting for the
memory the code is using and so on, so we had to make an aproximation.




------------------

# Compiler and flags
NVCC       = nvcc
CC         = gcc
CFLAGS     = -O2 -Wall
NVCCFLAGS  = -O2 -Xcompiler -fopenmp

# Graphics libraries
LIBS       = -lGL -lGLU -lglut -lm

# Source files
C_SOURCES   = $(wildcard *.c)
CU_SOURCES  = $(wildcard *.cu)
OBJECTS     = $(C_SOURCES:.c=.o) $(CU_SOURCES:.cu=.o)

# Output binary
TARGET = main

# Default rule
all: $(TARGET)

# Link all objects into final executable
$(TARGET): $(OBJECTS)
	$(NVCC) $(NVCCFLAGS) -o $@ $^ $(LIBS)

# Compile C files
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Compile CUDA files
%.o: %.cu
	$(NVCC) $(NVCCFLAGS) -c $< -o $@

# Clean rule
clean:
	rm -f $(OBJECTS) $(TARGET)

# Headless version (no graphics)
headless: headless.o solver.o wtime.o lin_solve.o
	$(NVCC) $(NVCCFLAGS) -o $@ $^

.PHONY: all clean headless

-----------------------------------------------------------------------------

# Compiler and flags
NVCC       = nvcc
CC         = gcc
CFLAGS     = -O2 -Wall
NVCCFLAGS  = -O2 -Xcompiler -fopenmp

# Graphics libraries
LIBS       = -lGL -lGLU -lglut -lm

# Source files
C_SOURCES   = $(wildcard *.c)
CU_SOURCES  = $(wildcard *.cu)
OBJECTS     = $(C_SOURCES:.c=.o) $(CU_SOURCES:.cu=.o)

# Output binary
TARGET = main

# Default rule
all: $(TARGET)

# Link all objects into final executable
$(TARGET): $(OBJECTS)
	$(NVCC) $(NVCCFLAGS) -o $@ $^ $(LIBS)

# Compile C files
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Compile CUDA files
%.o: %.cu
	$(NVCC) $(NVCCFLAGS) -c $< -o $@

# Clean rule
clean:
	rm -f $(OBJECTS) $(TARGET)

# Headless version (no graphics)
headless: headless.o solver.o wtime.o lin_solve.o
	$(NVCC) $(NVCCFLAGS) -o $@ $^

.PHONY: all clean headless